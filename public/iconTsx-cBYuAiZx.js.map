{"version":3,"file":"iconTsx-cBYuAiZx.js","sources":["../src/components/scrollable2.tsx","../src/components/iconTsx.tsx"],"sourcesContent":["/*\n * https://github.com/morethanwords/tweb\n * Copyright (C) 2019-2021 Eduard Kuzmenko\n * https://github.com/morethanwords/tweb/blob/master/LICENSE\n */\n\nimport {resolveElements} from '@solid-primitives/refs';\nimport {createEffect, createMemo, createSignal, JSX, on, onCleanup, Ref} from 'solid-js';\nimport {IS_OVERLAY_SCROLL_SUPPORTED} from '../environment/overlayScrollSupport';\nimport IS_TOUCH_SUPPORTED from '../environment/touchSupport';\nimport {IS_MOBILE_SAFARI, IS_SAFARI} from '../environment/userAgent';\nimport cancelEvent from '../helpers/dom/cancelEvent';\nimport classNames from '../helpers/string/classNames';\nimport useHeavyAnimationCheck from '../hooks/useHeavyAnimationCheck';\n\nconst SCROLL_THROTTLE = /* IS_ANDROID ? 200 :  */24;\nconst USE_OWN_SCROLL = !IS_OVERLAY_SCROLL_SUPPORTED;\n\nlet throttleMeasurement: (callback: () => void) => number,\n  cancelMeasurement: (id: number) => void;\nif(USE_OWN_SCROLL) {\n  throttleMeasurement = (callback) => requestAnimationFrame(callback);\n  cancelMeasurement = (id) => cancelAnimationFrame(id);\n} else {\n  throttleMeasurement = (callback) => window.setTimeout(callback, SCROLL_THROTTLE);\n  cancelMeasurement = (id) => window.clearTimeout(id);\n}\n\nexport default function Scrollable(props: {\n  children: JSX.Element,\n  ref?: Ref<HTMLDivElement>,\n  thumbRef?: (el: HTMLDivElement) => void,\n  class?: string,\n  axis?: 'x' | 'y',\n  withBorders?: 'both' | 'top' | 'bottom' | 'manual',\n  onScrolledTop?: () => void,\n  onScrolledBottom?: () => void,\n  onScroll?: () => void,\n  onScrollOffset?: number\n}) {\n  const axis = props.axis ?? 'y';\n  const scrollPositionProperty: 'scrollTop' | 'scrollLeft' = axis === 'x' ? 'scrollLeft' : 'scrollTop';\n  const scrollSizeProperty: 'scrollHeight' | 'scrollWidth' = axis === 'x' ? 'scrollWidth' : 'scrollHeight';\n  const clientSizeProperty: 'clientHeight' | 'clientWidth' = axis === 'x' ? 'clientWidth' : 'clientHeight';\n  const offsetSizeProperty: 'offsetHeight' | 'offsetWidth' = axis === 'x' ? 'offsetWidth' : 'offsetHeight';\n  const clientAxis: 'clientY' | 'clientX' = axis === 'x' ? 'clientX' : 'clientY';\n\n  const scrollPosition = () => ref[scrollPositionProperty];\n  const scrollSize = () => ref[scrollSizeProperty];\n  const clientSize = () => ref[clientSizeProperty];\n  const offsetSize = () => ref[offsetSizeProperty];\n  const getDistanceToEnd = () => scrollSize() - Math.round(scrollPosition() + offsetSize());\n\n  const onScrollOffset = createMemo(() => props.onScrollOffset ?? 300);\n\n  let lastScrollDirection: -1 | 0 | 1 = 0;\n  let lastScrollPosition = 0;\n\n  let startMousePosition: number;\n  let startScrollPosition: number;\n\n  let isHeavyAnimationInProgress = false;\n  let needCheckAfterAnimation = false;\n\n  const [isScrolledToStart, setIsScrolledToStart] = createSignal(true);\n  const [isScrolledToEnd, setIsScrolledToEnd] = createSignal(true);\n\n  let onScrollMeasure = 0;\n\n  const removeHeavyAnimationListener = useHeavyAnimationCheck(() => {\n    isHeavyAnimationInProgress = true;\n\n    if(onScrollMeasure) {\n      cancelMeasure();\n      needCheckAfterAnimation = true;\n    }\n  }, () => {\n    isHeavyAnimationInProgress = false;\n\n    if(needCheckAfterAnimation) {\n      onScroll();\n      needCheckAfterAnimation = false;\n    }\n  });\n\n  onCleanup(removeHeavyAnimationListener);\n\n  const onScroll = () => {\n    // if(this.debug) {\n    // this.log('onScroll call', this.onScrollMeasure);\n    // }\n\n    // return;\n\n    if(isHeavyAnimationInProgress) {\n      cancelMeasure();\n      needCheckAfterAnimation = true;\n      return;\n    }\n\n    // if(this.onScrollMeasure || ((this.scrollLocked || (!this.onScrolledTop && !this.onScrolledBottom)) && !this.splitUp && !this.onAdditionalScroll)) return;\n    if((!props.onScrolledTop && !props.onScrolledBottom)/*  && !this.splitUp */ && !onScrollCallbacks().length && !USE_OWN_SCROLL) return;\n    if(onScrollMeasure) return;\n    onScrollMeasure = throttleMeasurement(() => {\n      onScrollMeasure = 0;\n\n      const _scrollPosition = scrollPosition();\n      lastScrollDirection = lastScrollPosition === _scrollPosition ? 0 : (lastScrollPosition < _scrollPosition ? 1 : -1); // * 1 - bottom, -1 - top\n      lastScrollPosition = _scrollPosition;\n\n      updateThumb(_scrollPosition);\n\n      // lastScrollDirection check is useless here, every callback should decide on its own\n      if(true/*  && lastScrollDirection !== 0 */) {\n        onScrollCallbacks().forEach((callback) => callback());\n      }\n\n      checkForTriggers();\n    });\n  };\n\n  const cancelMeasure = () => {\n    if(onScrollMeasure) {\n      cancelMeasurement(onScrollMeasure);\n      onScrollMeasure = 0;\n    }\n  };\n\n  const checkForTriggers = () => {\n    if(!props.onScrolledTop && !props.onScrolledBottom) return;\n\n    // if(this.isHeavyAnimationInProgress) {\n    //   this.onScroll();\n    //   return;\n    // }\n\n    const _scrollSize = scrollSize();\n    if(!_scrollSize) { // незачем вызывать триггеры если блок пустой или не виден\n      return;\n    }\n\n    const _scrollPosition = scrollPosition();\n    const _clientSize = offsetSize();\n    const _onScrollOffset = onScrollOffset();\n    const maxScrollPosition = _scrollSize - _clientSize;\n\n    // this.log('checkForTriggers:', scrollTop, maxScrollTop);\n\n    if(props.onScrolledTop && _scrollPosition <= _onScrollOffset && lastScrollDirection <= 0/* && direction === -1 */) {\n      props.onScrolledTop();\n    }\n\n    if(props.onScrolledBottom && (maxScrollPosition - _scrollPosition) <= _onScrollOffset && lastScrollDirection >= 0/* && direction === 1 */) {\n      props.onScrolledBottom();\n    }\n  };\n\n  const checkEnds = () => {\n    setIsScrolledToStart(!scrollPosition());\n    setIsScrolledToEnd(getDistanceToEnd() <= 1);\n  };\n\n  const updateThumb = (_scrollPosition = scrollPosition()) => {\n    if(!USE_OWN_SCROLL || !thumbRef) {\n      return;\n    }\n\n    const _scrollSize = scrollSize();\n    const _clientSize = clientSize();\n    const divider = _scrollSize / _clientSize / 0.75;\n    const thumbSize = Math.max(20, _clientSize / divider);\n    const value = _scrollPosition / (_scrollSize - _clientSize) * _clientSize;\n    // const b = (scrollPosition + clientSize) / scrollSize;\n    const b = _scrollPosition / (_scrollSize - _clientSize);\n    const maxValue = _clientSize - thumbSize;\n    if(_clientSize < _scrollSize) {\n      thumbRef.style.height = thumbSize + 'px';\n      // this.thumb.style.top = `${Math.min(maxValue, value - thumbSize * b)}px`;\n      thumbRef.style.transform = `translateY(${Math.min(maxValue, value - thumbSize * b)}px)`;\n    } else {\n      thumbRef.style.height = '0px';\n    }\n  };\n\n  const onScrollCallbacks = createMemo(() => [props.onScroll, props.withBorders && checkEnds].filter(Boolean));\n\n  const onThumbMouseMove = (e: MouseEvent) => {\n    cancelEvent(e);\n\n    const contentHeight = scrollSize();\n    const viewportHeight = clientSize();\n    const scrollbarSize = thumbRef.offsetHeight;\n    const maxScrollTop = contentHeight - viewportHeight;\n\n    const maxScrollbarOffset = viewportHeight - scrollbarSize;\n    const deltaY = e[clientAxis] - startMousePosition;\n    const scrollAmount = (deltaY / maxScrollbarOffset) * maxScrollTop;\n    const newScrollTop = startScrollPosition + scrollAmount;\n\n    ref[scrollPositionProperty] = newScrollTop;\n  };\n\n  const onThumbMouseDown = (e: MouseEvent) => {\n    cancelEvent(e);\n    startMousePosition = e[clientAxis];\n    startScrollPosition = scrollPosition();\n    (e.target as HTMLElement).classList.add('is-focused');\n\n    window.addEventListener('mousemove', onThumbMouseMove);\n    window.addEventListener('mouseup', onThumbMouseUp, {once: true});\n  };\n\n  const onThumbMouseUp = (e: MouseEvent) => {\n    window.removeEventListener('mousemove', onThumbMouseMove);\n    thumbRef.classList.remove('is-focused');\n  };\n\n  const onWheel = (e: WheelEvent) => {\n    e.stopPropagation();\n    const target = e.target as HTMLElement;\n    if(!e.deltaX && target.scrollWidth > target.clientWidth) {\n      target.scrollLeft += e.deltaY / 4;\n      cancelEvent(e);\n    }\n  };\n\n  const onSizeChange = () => {\n    if(USE_OWN_SCROLL && thumbRef) {\n      onScroll();\n    }\n  };\n\n  const children = resolveElements(() => props.children);\n\n  createEffect(on(children, onSizeChange));\n\n  let ref: HTMLDivElement, thumbRef: HTMLDivElement;\n  return (\n    <div\n      ref={(_ref) => (ref = _ref, (props.ref as any)?.(_ref))}\n      class={classNames(\n        'scrollable',\n        `scrollable-${axis}`,\n        props.class,\n        IS_SAFARI && !IS_MOBILE_SAFARI && 'no-scrollbar',\n        ...(props.withBorders ? [\n          isScrolledToStart() && 'scrolled-start',\n          isScrolledToEnd() && 'scrolled-end',\n          axis === 'y' && 'scrollable-y-bordered',\n          (props.withBorders === 'top' || props.withBorders === 'both') && 'scrollable-y-bordered-top',\n          (props.withBorders === 'bottom' || props.withBorders === 'both') && 'scrollable-y-bordered-bottom'\n        ] : [])\n      )}\n      onScroll={onScroll}\n      onWheel={(axis === 'x' && !IS_TOUCH_SUPPORTED && onWheel) || undefined}\n    >\n      {USE_OWN_SCROLL && axis === 'y' && (\n        <div class=\"scrollable-thumb-container\">\n          <div\n            class=\"scrollable-thumb\"\n            ref={(el) => {\n              thumbRef = el;\n              props.thumbRef?.(el);\n            }}\n            onMouseDown={onThumbMouseDown}\n          ></div>\n        </div>\n      )}\n      {children()}\n    </div>\n  );\n}\n","import {JSX, splitProps} from 'solid-js';\nimport classNames from '../helpers/string/classNames';\nimport {getIconContent} from './icon';\n\nexport const IconTsx = (props: {icon: Icon} & JSX.HTMLAttributes<HTMLSpanElement>) => {\n  const [, rest] = splitProps(props, ['icon']);\n  return (\n    <span {...rest} class={classNames('tgico', props.class)}>\n      {getIconContent(props.icon)}\n    </span>\n  );\n};\n"],"names":["SCROLL_THROTTLE","USE_OWN_SCROLL","IS_OVERLAY_SCROLL_SUPPORTED","throttleMeasurement","cancelMeasurement","callback","requestAnimationFrame","id","cancelAnimationFrame","window","setTimeout","clearTimeout","Scrollable","props","axis","scrollPositionProperty","scrollSizeProperty","clientSizeProperty","offsetSizeProperty","clientAxis","scrollPosition","ref","scrollSize","clientSize","offsetSize","getDistanceToEnd","Math","round","onScrollOffset","createMemo","lastScrollDirection","lastScrollPosition","startMousePosition","startScrollPosition","isHeavyAnimationInProgress","needCheckAfterAnimation","isScrolledToStart","setIsScrolledToStart","createSignal","isScrolledToEnd","setIsScrolledToEnd","onScrollMeasure","removeHeavyAnimationListener","useHeavyAnimationCheck","cancelMeasure","onScroll","onCleanup","onScrolledTop","onScrolledBottom","onScrollCallbacks","length","_scrollPosition","updateThumb","forEach","checkForTriggers","_scrollSize","_clientSize","_onScrollOffset","maxScrollPosition","checkEnds","thumbRef","divider","thumbSize","max","value","b","maxValue","style","height","transform","min","withBorders","filter","Boolean","onThumbMouseMove","e","cancelEvent","contentHeight","viewportHeight","scrollbarSize","offsetHeight","maxScrollTop","maxScrollbarOffset","scrollAmount","newScrollTop","onThumbMouseDown","target","classList","add","addEventListener","onThumbMouseUp","once","removeEventListener","remove","onWheel","stopPropagation","deltaX","scrollWidth","clientWidth","scrollLeft","deltaY","onSizeChange","children","resolveElements","createEffect","on","_el$","_tmpl$","_$addEventListener","IS_TOUCH_SUPPORTED","undefined","_$use","_ref","_$insert","_el$2","_tmpl$2","_el$3","firstChild","$$mousedown","el","_$effect","_$className","classNames","class","IS_SAFARI","IS_MOBILE_SAFARI","_$delegateEvents","IconTsx","rest","splitProps","_$spread","_$mergeProps","getIconContent","icon"],"mappings":"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"}